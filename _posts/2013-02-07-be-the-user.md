---
layout: post
category: Software is Made by People
---
{% include JB/setup %}

Making good software is difficult, but not for everybody. Some people, often small teams or lone developers, will create true gems which can be tenfold better than what a company on a large budget will release. I could give examples like the first Unix and most computer languages, but you all have seen some brilliant piece of software written by one guy, or a small team that worked particularly well together.

As a side note, you might wonder how to judge software, how to know it is brilliant. I'm very much interested in the subject but I'll keep that one for another time as this post is about to take a different direction. Let's assume brilliant software is software which will make most users consistently happy. Even if it is a vague one, I hope everybody will agree that it's a reasonable target.

When making software, if you want to make a user happy you have to think like him, you have to *be* the user. From that logic, you realise quickly the ideal world is a developer developing software for himself. And most of the time that's when good software is made.

Now let's take a step back and look at a standard scenario where a random software company makes software for other companies. We'll assume the software company is building a new product from scratch to help a client replace rudimentary tools by more efficient ones. The software company doesn't employ any user, or ex-user, with some sort of vision of what the product is going to be, this means our software company will rely on its relations with the client to know what should go in that product. <br>
A standard project plan could be:
0. Client agrees to buy the future product
1. Client creates a project team on its side, users are part of it in the limit of their availibility
2. Software company creates a project team, with a product owner, a project lead and developers.
3. Workshops are organised to flesh out the requirements
4. Development is done with some intermediary validations from the client in an Agile way
5. Final delivery going live is done after 1 year of development
<br><br>
Let's assume everything went well: the client was relatively mature about what he wanted, the specifications were as good as a specification can be, the development team worked well together.

This way to do things is a standard, proven by the market, way to make software. Billions are made by software companies which sell software made this way, SAP being the first and best example for that model.

But this kind of software doesn't make users consistently happy. They will still have bouts of nostalgia for the Excel sheet being replaced. What will be missing is an efficient way to do common things, some flexibility when needed, and some consistency throughout all the features. Usability will also be an issue. The whole application will feel like there could have been some maturation. It's important to note that this is usually fine as the benefit of having a standard application throughout the company is a great step forward for reliability and reporting capabilities.

This is not brilliant software though. The brilliant software should make the user forget about Excel and what he was using it for. But this result is not attainable with this standard model of making software. The makers are far too far from the users and their detailed needs. The makers actually don't know anything about all the things that go through a user's mind when doing his work. Even if the teams are small, there are too many stakeholders, too many decision makers, too many intermediaries. The necessary iterative loops to improve features are simply too slow to reach mature features in a reasonable time frame.

To reach maturity quickly, there is only one way, the makers need to *be* the user. How can this happen? Asking the question is half the answer: the users need to be part of the development team. Users testing the software with their own data that they know and understand, users having ideas directly discussed with the product owner and developers, users understanding the logic behind a software product making, that kind of teamwork can make features maturity gain years compared with a process involving more intermediaries.

How could such a process work when it involves two companies with completely different goals? I don't know anything about partnership or consortium, but I feel that's what b2b software products need, partnerships. Partnership is not easy of course, and there are some governance and revenue considerations to take into account. But let's not forget the target of all the work being done: users of the software being made need to get more efficient at what they do.

**Note:** Going this direction raises an important question around the fact the software needs to be sold to other clients. How do we introduce genericity when we have users with a very specific requirement sitting beside us? I think the requirements are never as specific as we think. Specific requirements are often one particular solution to a generic problem which is shared by many other companies. Working closely with users allows digging more behind the specific requirement to find the generic problem behind it. But this needs another post.
